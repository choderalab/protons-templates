{% extends "protons_base.j2" %}
{% block imports %}
from __future__ import print_function
from protons import app
from simtk import unit, openmm as mm
from protons.app import ConstantPHCalibration, ForceFieldProtonDrive, NCMCProtonDrive
from protons.app import MetadataReporter, TitrationReporter, NCMCReporter, SAMSReporter
import shutil
import signal
import json
from protons.app.logger import log, logging
import numpy as np
from openmmtools.integrators import LangevinIntegrator, ExternalPerturbationLangevinIntegrator
log.setLevel(logging.DEBUG)
import os
import netCDF4
import saltswap
{% endblock %}



{% block simulation_input %}
# Input files
input_pdb_file = "{{ input.pdbfile }}"
ligand_xml = "{{ input.ligandxml }}"

# Load the PDB file and the forcefield files
pdb_object = app.PDBFile(input_pdb_file)
forcefield = app.ForceField('amber10-constph.xml', 'gaff.xml', ligand_xml, 'tip3p.xml', 'ions_tip3p.xml')

# Prepare the Simulation
topology = pdb_object.topology
positions = pdb_object.positions

# Quick fix for histidines in topology
for residue in topology.residues():
    if residue.name == 'HIS':
        residue.name = 'HIP'
{% endblock %}


{% block simulation_output %}
# Naming the output files
basename = "{{ output.basename|default(output) }}"
name_netcdf = '%s.nc' % basename
dcd_output_name = '%s.dcd' %basename
weights_txt_name = '%s-weights.txt' % basename
output_context_xml = "resume-%s-state.xml" % basename
output_drive_xml = "resume-%s-drive.xml" % basename
output_calibration_json = "resume-%s-calibration.json" % basename
{% endblock %}


{# Generic settings for the simulation loops #}
{% block dynamics_settings %}
# Steps of MD before starting the main loop
num_thermalization_steps = {{ simulation.num_thermalization_steps|default('10000') }}
# Steps of MD in between MC moves
steps_between_updates = {{ simulation.steps_between_updates|default('10000') }}
{% endblock %}


{# By default we're using CUDA #}
{% block platform_settings %}
# Platform Options
platform = mm.Platform.getPlatformByName('CUDA')
properties = {'CudaPrecision': 'mixed', 'DeterministicForces': 'true', 'CudaDeviceIndex': os.environ['CUDA_VISIBLE_DEVICES']}
{% endblock %}


{# Timestep, collision rate, constraints #}
{% block integrator_settings %}
# Integrator options
timestep = {{ integrator.timestep|default('2.0') }} * unit.femtosecond
constraint_tolerance = {{ integrator.constraint_tolerance|default('1.e-7') }}
collision_rate = {{ integrator.collision_rate|default('1.0') }} / unit.picosecond
{% endblock %}


{# ProtonDrive settings #}
{% block driver_settings %}
 # Number of attempts per protein update
nattempts_protein = {{ driver.num_attempts_protein|default('5') }}
ncmc_steps_per_trial = {{ driver.ncmc_steps_per_trial|default('10000') }}  # 20 ps / 20 fs
prop_steps_per_trial = {{ driver.prop_per_step|default('1')}}
total_iterations = {{ driver.total_iterations|default('10000') }}

modulo_ligand_update = 1 # Update ligand every n iterations
modulo_protein_update = 1 # Update protein every n iterations
{% endblock %}


{# Settings that affect pre-simulation minimization #}
{% block minimization_settings %}
pre_run_minimization_tolerance = 1e-5 * unit.kilojoule / unit.mole
minimization_max_iterations = 0
{% endblock %}


{# SAMS calibration specific settings #}
{% block sams_settings %}
# SAMS settings
beta_burnin = {{ sams.beta|default('0.5') }}
flatness_criterion = {{ sams.flatness_criterion|default('0.15') }}
{% endblock %}


{% block system_settings %}
# System Configuration
nonbondedMethod = app.PME
constraints = app.HBonds
rigidWater = True
ewaldErrorTolerance = {{ system.ewaldErrorTolerance|default('1.e-5') }}
barostatInterval =  {{ system.barostatInterval|default('25') }}
switching_distance = {{ system.switching_distance|default('0.85') }} * unit.nanometers
nonbondedCutoff = {{ system.nonbondedCutoff|default('1.0') }} * unit.nanometers
pressure = {{ system.pressure|default('1.0') }} * unit.atmosphere
temperature = {{ system.temperature|default('300.0') }} * unit.kelvin

system = forcefield.createSystem(topology, nonbondedMethod=nonbondedMethod, constraints=constraints,
                                 rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance, nonbondedCutoff=nonbondedCutoff)

#
for force in system.getForces():
    if isinstance(force, mm.NonbondedForce):
        force.setUseSwitchingFunction(True)

        force.setSwitchingDistance(switching_distance)

# NPT simulation
system.addForce(
    mm.MonteCarloBarostat(
        pressure,
        temperature,
        barostatInterval))

{% endblock %}


{# Reporters for logging simulation data to DCD (coordinates) and netcdf #}
{% block reporters %}
dcdreporter = app.DCDReporter(dcd_output_name, int(steps_between_updates/30))
ncfile = netCDF4.Dataset(name_netcdf, "w")
metdatarep = MetadataReporter(ncfile, shared=True)
ncmcrep = NCMCReporter(ncfile,1,shared=True)
titrep = TitrationReporter(ncfile,1,shared=True)
simulation.reporters.append(dcdreporter)
simulation.update_reporters.append(metdatarep)
simulation.update_reporters.append(ncmcrep)
simulation.update_reporters.append(titrep)
{% endblock %}

{# Used for resuming simulations #}
{% block serialization_functions %}
def serialize_state(context, outputfile):
    """
    Serialize the simulation state to xml.
    """
    xmls = mm.XmlSerializer
    statexml = xmls.serialize(context.getState(getPositions=True, getVelocities=True))
    with open(outputfile,'w') as statefile:
        statefile.write(statexml)

def serialize_drive(drive, outputfile):
    """
    Serialize the drive residues to xml.
    """
    drivexml = drive.serialize_titration_groups()
    with open(outputfile, 'wb') as drivefile:
        drivefile.write(drivexml)

def serialize_sams_status(calibration, outputfile):
    """
    Serialize the state of the SAMS calibration as json
    """
    samsProperties = calibration.export_samsProperties()
    samsjson = json.dumps(samsProperties, sort_keys=True, indent=4, separators=(',', ': '))
    with open(outputfile, 'w') as samsfile:
        samsfile.write(samsjson)
{% endblock %}

{% block resume_files %}
input_state_xml = "{{ script.resume.state_xml }}"
input_drive_xml = "{{ script.resume.drive_xml }}"
input_sams_json = "{{ script.resume.sams_json}}"
{% endblock %}

{# Defines and uses gbaoab integrator in simulation #}
{% block integrator_def %}
number_R_steps = {{ integrator.number_R_steps|default(1) }}

class ExternalGBAOABIntegrator(ExternalPerturbationLangevinIntegrator):
    """
    Implementation of the gBAOAB integrator which tracks external protocol work.

    Parameters
    ----------
        number_R: int, default: 1
            The number of sequential R steps.  For instance V R R O R R V has number_R = 2
        temperature : simtk.unit.Quantity compatible with kelvin, default: 298*unit.kelvin
           The temperature.
        collision_rate : simtk.unit.Quantity compatible with 1/picoseconds, default: 1.0/unit.picoseconds
           The collision rate.
        timestep : simtk.unit.Quantity compatible with femtoseconds, default: 1.0*unit.femtoseconds
           The integration timestep.


    """

    def __init__(self, number_R_steps=1, temperature=298.0 * unit.kelvin,
                 collision_rate=1.0 / unit.picoseconds,
                 timestep=1.0 * unit.femtoseconds,
                 constraint_tolerance=1e-7
                 ):
        Rstep = " R" * number_R_steps

        super(ExternalGBAOABIntegrator, self).__init__(splitting="V{0} O{0} V".format(Rstep),
                                                       temperature=temperature,
                                                       collision_rate=collision_rate,
                                                       timestep=timestep,
                                                       constraint_tolerance=constraint_tolerance,
                                                       measure_shadow_work=False,
                                                       measure_heat=False,
                                                       )
{% endblock %}


{# ProtonDrive definitions, based on resumed from xml #}
{% block resume_drive %}
xmlserializer = mm.XmlSerializer
state = input_state_xml
driver = NCMCProtonDrive(temperature, topology, system, pressure=pressure, perturbations_per_trial=ncmc_steps_per_trial, propagations_per_step=prop_steps_per_trial)
with open(input_drive_xml, 'r') as serialized_drive:
     driver.add_residues_from_serialized_xml(serialized_drive.read())

{% endblock %}

{# Defines a new protondrive from forcefield, system and topology #}
{% block new_drive %}

driver = ForceFieldProtonDrive(temperature, topology, system, forcefield, ['amber10-constph.xml', ligand_xml], pressure=pressure,
                                       perturbations_per_trial=ncmc_steps_per_trial, propagations_per_step=prop_steps_per_trial)

# Initializing the weights using values from previous simulations
g_initial = {'TYR': [0.0, 126.7],
                 'AS4': [0.0, -63.2, -65.1, -63.1, -69.5],
                 'GL4': [0.0, -33.8, -39.7, -36.1, -38.5],
                 'HIP': [0.0, 27.5, 29.6],
                 'CYS': [0.0, 154.4],
                 'LYS': [0.0, -6.8]}
driver.import_gk_values(g_initial)
driver.adjust_to_ph(7.4)
{% endblock %}

{# Define pooling of residues for selective updates #}
{% block def_pools %}
# Define residue pools
pools = {
    'protein_titratable_residues' : list(range(ligand_titration_group_index)),
    'ligand' : [ligand_titration_group_index]}
driver.define_pools(pools)
{% endblock %}


{# Instantiate a GBAOAB integrator for simulation #}
{% block integrator_init %}

integrator = ExternalGBAOABIntegrator(number_R_steps=number_R_steps, temperature=temperature, collision_rate=collision_rate, timestep=timestep, constraint_tolerance=constraint_tolerance)
ncmc_propagation_integrator = ExternalGBAOABIntegrator(number_R_steps=number_R_steps, temperature=temperature, collision_rate=collision_rate, timestep=timestep, constraint_tolerance=constraint_tolerance)

# Define a compound integrator
compound_integrator = mm.CompoundIntegrator()
compound_integrator.addIntegrator(integrator)
compound_integrator.addIntegrator(ncmc_propagation_integrator)
compound_integrator.setCurrentIntegrator(0)
{% endblock %}


{# Defining calibration run #}
{% block resume_sams %}
# Resume calibration from previous run, using json as input
input_sams_json = "{{ script.resume.sams_json}}"
with open(input_sams_json, 'r') as sams_json_file:
    samsProperties = json.loads(sams_json_file.read())

simulation = app.ConstantPHCalibration(topology, system, compound_integrator, driver, group_index=ligand_titration_group_index, platform=platform, platformProperties=properties, state=state, samsProperties=samsProperties)
{% endblock %}


{# Define a new ConstantPHCalibration run#}
{% block start_sams %}
simulation = app.ConstantPHCalibration(topology, system, compound_integrator, driver, group_index=ligand_titration_group_index, platform=platform, platformProperties=properties)
simulation.context.setPositions(positions)
simulation.minimizeEnergy(tolerance=pre_run_minimization_tolerance, maxIterations=minimization_max_iterations)
simulation.step(num_thermalization_steps)
{% endblock %}
{% block calibration_reporters %}
samsrep = SAMSReporter(ncfile,1,shared=True)
simulation.calibration_reporters.append(samsrep)
{% endblock %}

{% block inner_loop %}
{# Needs ident of two tabs #}
        log.info("Iteration %i", i)
        if i == 5:
            log.info("Simulation seems to be working. Suppressing debugging info.")
            log.setLevel(logging.INFO)
        simulation.step(steps_between_updates)        
        simulation.update(nattempts_protein, pool='protein_titratable_residues')        
        simulation.update(1, pool='ligand')
        simulation.adapt()
{% endblock %}